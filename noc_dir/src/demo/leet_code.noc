import "src/collections/linked_list.noc"
import "src/collections/stack.noc"
import "src/demo/traversal.noc"
import "src/collections/arr_utils.noc"

// 0(n) space and time 
function bool is_palindrome(linked_list<int> list) {
    stack = new stack<int>();
    init_stack(stack);
    size_of_list = 0;
    current_node = list.head;
    for {
        if (current_node != null) {
            size_of_list++;
            current_node = current_node.next;
        } else {
            break;
        }
    }

    if (size_of_list <= 2) {
        return true;
    }

    if ((size_of_list % 2)  == 0) {
        return false;
    }

    mid_point = size_of_list / 2;
    current_index = 0;

    // reset head 
    current_node = get_head(list);
    for {
        if (current_index != mid_point) {
            current_index++;
    
            push(stack, current_node.value);
        } else {
            top = pop(stack);
            if (top != current_node.value) {
                return false;
            }
        }
        current_node = current_node.next;
        if (current_node == null) {
            break;
        }
    }
    return true;
}

function bool is_palindrome_constant_space(linked_list<int> list) {
    size_of_list = 0;
    current_node = list.head;
    for {
        if (current_node != null) {
            size_of_list++;
            current_node = current_node.next;
        } else {
            break;
        }
    }

    if (size_of_list <= 2) {
        return true;
    }

    if ((size_of_list % 2)  == 0) {
        return false;
    }

    mid_point = size_of_list / 2;

    previous_node_from_current::node<int> = null;
    node_after_mid_point::node<int> = null;
    node_before_mid_point::node<int> = null;

    previous_node = get_head(list);
    if (previous_node == null) {
        return false;
    }

    current_node = previous_node.next;
    next_node = current_node;
    iterator_index = 2; // We start at two because we have already visited head and after head 
    for {
        current_node = next_node;
        next_node = next_node.next;
        current_node.next = previous_node;
        previous_node = current_node;

        if (iterator_index == mid_point) {
            node_after_mid_point = next_node;
            node_before_mid_point = current_node;
            break;
        }
        iterator_index++;
    }

    current_node_forward::node<int> = node_after_mid_point;
    current_node_backward::node<int> = node_before_mid_point;

    for {
        if (current_node_forward == null) {
            break;
        }

        if (current_node_forward.value != current_node_backward.value) {
            return false;
        }

        current_node_forward = current_node_forward.next;
        current_node_backward = current_node_backward.next;
    }
    return true;
}

function int[] next_greatest(int[] nums_two) {
    stack = new stack<int>();
    init_stack(stack);
    map = new int[nums_two.len + 1];
        
    // init map 
    for (i =0 ; i<map.len; i++) {
        map[i] = -1;
    }

    for (i=0; i<nums_two.len; i++) {
        if (is_empty(stack)) {
            push(stack, nums_two[i]);   
            continue;
        }
        top = peek(stack);
        if (nums_two[i] <= top) {
            push(stack, nums_two[i]);
        }  else {
            for {
                if (is_empty(stack)) {
                    break;
                }
                top =  pop(stack);
                map[top] = nums_two[i];
            }
            push(stack, nums_two[i]);
        }
    }

    return map;
}


function bool back_space_on_space(char[] str_one, char[] str_two) { 

    if (str_one.len != str_two.len) {    
        return false;
    }

    str_one_stack = new stack<char>();
    init_stack(str_one_stack);

    str_two_stack = new stack<char>();
    init_stack(str_two_stack);

    function push_character(stack<char> stack, char character) {
        if (character == '#') {
            if (is_empty(stack) == false) {
                pop(stack);
            }
        } else {
            push(stack, character);
        }
    }

    for (i=0; i<str_one.len; i++) {
        character = str_one[i];
        character_two = str_two[i];

        push_character(str_one_stack, character);
        push_character(str_two_stack, character_two);
    }

    for {
        if (is_empty(str_one_stack) || is_empty(str_two_stack)) {
            break;
        }

        char_one = pop(str_one_stack);
        char_two = pop(str_two_stack);
    
        if (char_one != char_two) {
            return false;
        }
    }

    return is_empty(str_one_stack) == is_empty(str_two_stack);
}

function bool back_space_fast(char[] str_one, char[] str_two) throws {

    function int find_first_non_deletatable_char_index(char[] str, int start_index)  throws  {
        
        if (start_index >= str.len) {
            throw error("find_first_non_deletatable_char:: start index is larger than string");
        }
        
        first_index = start_index;
        num_back_spaces = 0;
    
        for (i=first_index; i>=0; i--) {
            character = str[i];
            if (character == '#') {
                // Cheecky hack
                if (i==0) {
                    return -1;
                }
                num_back_spaces++;
                continue;
            } else {
                if (num_back_spaces != 0) {
                    first_index = i - num_back_spaces;
                    num_back_spaces = 0;
                    continue;
                } else {
                    first_index = i;
                    break;
                }        
            }
        }

        if (first_index <0) {
            return -1;
        }

        return first_index;
    }


    index_to_search_str_one = str_one.len -1;
    index_to_search_str_two = str_two.len -1;

    for {
        found_index_one = try find_first_non_deletatable_char_index(str_one, index_to_search_str_one);
        found_index_two = try find_first_non_deletatable_char_index(str_two, index_to_search_str_two);
        

        if (found_index_one == -1 || found_index_two == -1) {
            return found_index_one == found_index_two;
        }

        if (str_one[found_index_one] != str_two[found_index_two]) { 
            return false;
        }

        index_to_search_str_one = found_index_one - 1;
        index_to_search_str_two = found_index_two - 1;
    }

    return true;
}


function TreeNode<int> increase_order_search_tree(TreeNode<int> tree_node) {

    function add_rightmost(TreeNode<int> node, int val) {
        current_node = node;
        for {
            if (current_node.right == null) {
                add_right_child(current_node, val);
                break;
            }
            current_node = current_node.right;
        }
    }

    function increase_order_search_tree_inner(TreeNode<int> tree_node, TreeNode<int> output) {
        if (tree_node.left != null) {
            increase_order_search_tree_inner(tree_node.left, output);
        } 

        add_rightmost(output, tree_node.value);
        
        if (tree_node.right != null) {
            increase_order_search_tree_inner(tree_node.right, output);
        }
    }

    output = new TreeNode<int>();
    increase_order_search_tree_inner(tree_node, output);
    return output.right;
}

function TreeNode<T> flatter_tree_to_linked_list(TreeNode<T> tree_node) {

    function TreeNode<T> find_right_most() {
        right_most = tree_node;
        for {
            if (right_most.right == null) {
                break;
            }
            right_most = right_most.right;
        }
        return right_most;
    }


    function TreeNode<T> traverse_and_append(TreeNode<T> current_node, TreeNode<T> right_most) {
        if (current_node == null) {
            return right_most;
        }
        right_most = add_right_child(right_most, current_node.value);
        right_most = traverse_and_append(current_node.left, right_most);
        right_most = traverse_and_append(current_node.right, right_most);
        return right_most;
    }
    
    right_most = find_right_most(); 
    printf("right most is %d", right_most.value);
    return right_most.right;
}

function matching_brackets() {

    function int is_closing(char[] close_input, char character) {
        return index_of(close_input, character);
    }
    
    function int is_open(char[] open_input, char character) {
        return is_closing(open_input, character);
    }
    
    open_input = new char[3];
    close_input = new char[3];

    open_input[0] = '(';
    open_input[1] = '{';
    open_input[2] = '[';

    close_input[0] = ')';
    close_input[1] = '}';
    close_input[2] = ']';

    brackets = new stack<char>();
    init_stack(brackets);

    input = new char[5];
    input[0] = '(';
    input[1] = ')';
    input[2] = '[';
    input[3] = ']';
    input[4] = '[';

    for (i = 0; i < input.len; i++) {
        result = is_closing(close_input, input[i]);
        if (result != -1) {
            if (is_empty(brackets)) {
                printf("stack empty invalid");
                return;
            }
            top = pop(brackets);
            index_of_open = is_open(open_input, top);
            index_of_close = is_closing(close_input, input[i]);
            if (index_of_open != index_of_close) {
                printf("Mismatch of brace :: invalid");
                return;
            }
        }
        else {
            push(brackets, input[i]);
        }
    }

    if (is_empty(brackets) == false) {
        printf("stack empty invalid\n");
    }
    else {
        printf("valid");
    }
}

function stack<char> remove_duplicates_with_stakc(char[] str) {

    stack = new stack<char>();
    init_stack(stack);
    for (i=0; i<str.len; i++) {
        if (is_empty(stack)) {
            push(stack, str[i]);
        } else {
            top = peek(stack);
            if (top == str[i]) {
                pop(stack);
            } else {
                push(stack, str[i]);
            }
        }
    }
    return stack;
}

function remove_duplicates_with_stack_test() {
    arr = new char[6];
    arr[0] = 'a';
    arr[1] = 'b';
    arr[2] = 'b';
    arr[3] = 'd';
    arr[4] = 'e';
    arr[5] = 'f';
    
    stack = remove_duplicates_with_stakc(arr);

    for {
        if(is_empty(stack)) {
            break;
        }
        value = pop(stack);
        printf("%c,", value);
    }    
}

function remove_duplicates_in_string(char[] str) {
    i = 0;
    adj_i = i + 1;

    map = new bool[str.len];
    for (j=0; j<str.len; j++) {
        map[j] = false;
    }

    for {
        if (i < 0) {
            // If i has fallen off array then reset it 
            adj_i++;
            i = adj_i -1;
            continue;
        }

        if (adj_i >= str.len) {
            break;
        }

        if (str[i] == str[adj_i]) {
            map[i] = true;
            map[adj_i] = true;
            adj_i++;
            i--;
        } else {
            adj_i++;
            i = adj_i - 1;
        }
    }

    for (i=0; i<map.len; i++) {
        if (map[i] == false) {
            printf("%d,", str[i]);
        }
    }
}

function reverse_prefix_with_queue(char[] str, char target) throws {
    queue = new queue<char>();
    init_queue(queue);
    found_pos = -1;

    for (i=0; i<str.len; i++) {
        enqueue(queue, str[i]);
        if (str[i] == target) {
            found_pos = i;
        }
    }

    if (found_pos == -1) {
        return;
    }

    for {
        if (found_pos <0) {
            break;
        }
        if (is_queue_empty(queue)) {
            throw error("queue is empty but found pos has not hit zero");
        }
        val = dequeue(queue);
        str[found_pos] = val;

        found_pos--;
    }
}

function revserse_prefix(char[] str, char target) {
    found_pos = -1;
    for (i=0; i<str.len; i++) {
        if (str[i] == target) {
            found_pos = i;
            break;
        }
    }
    
    if (found_pos == -1) {
        return;
    }

    begin = 0;
    for {
        if (begin >= found_pos) {
            break;
        }
        tmp = str[found_pos];
        str[found_pos] = str[begin];
        str[begin] = tmp;
        begin++;
        found_pos--;
    }
}

function clear_digist(char[] str) throws {

    function bool is_char_number(char c) {
        if (c >= '0' && c<='9') {
            return true;
        }
        return false;
    }

    if (str.len == 0) {
        throw error("str is null or empty");
    }

    stack = new stack<char>();
    init_stack(stack);

    if (is_char_number(str[0]) == false) {
        push(stack, str[0]);
    }

    for (i=1; i<str.len; i++) {
        if (is_char_number(str[i])) {
            if (is_empty(stack)) {
                continue;
            } else {
                pop(stack);
            }
        } else {
            push(stack, str[i]);
        }
    }

    for {
        if(is_empty(stack)) {
            break;
        }
        val = pop(stack);
        printf("%c,", val);
    }
}

function make_string_great(char[] str) {

    function char to_upper_case(char c) {
        difference = 'a' - 'A';
        if (c >= 'a') {
            result = c - difference;
            return result;
        }
        return c;
    }

    stack = new stack<char>();
    init_stack(stack);
    push(stack, str[0]);

    for (i=1; i<str.len; i++) {
        if (is_empty(stack)) {
            push(stack, str[i]);
            continue;
        }
        top = peek(stack);
        top_as_upper = to_upper_case(top);

        if (top_as_upper == str[i]) {
            pop(stack);
        } else {
            
            push(stack, str[i]);
        }
    }

    for {
        if(is_empty(stack)) {
            break;
        }
        val = pop(stack);
        printf("%c,", val);
    }
}


enum OperatorType {
    ADD,
    MINUS,
    MULTPLY, 
    DIVIDE,
    NO_MATCH
}

function int eval_reverse_polish_notiation(char[][] strings) throws {

    function OperatorType map_to_operator_type(char operand) {

        if(operand == '-') {
            return OperatorType.MINUS;
        }

        if(operand == '+') {
            return OperatorType.ADD;
        }

        if(operand == '*') {
            return OperatorType.MULTPLY;
        }

        if(operand == '/') {
            return OperatorType.DIVIDE;
        }

        return OperatorType.NO_MATCH;
    }

    function is_char_valid(char character) throws {
        if (character < '0' || character > '9') {
            throw error("bad character string");
        }
    }

    function int char_arr_to_int(char[] arr) throws {
        result::int = 0;
        multiplier = 1;
        for (i =arr.len - 1; i>=0; i--) {
            try is_char_valid(arr[i]);
            int_value::int = arr[i] - '0';
            int_value = int_value * multiplier;
            result = result + int_value;
            multiplier = multiplier * 10;
        }
        return result;
    }

    operands = new stack<int>();
    init_stack(operands);

    function eval_string(char[] str) throws {
        if (str.len == 1) {
            character = str[0];
            operator_type = map_to_operator_type(character);
    
            match operator_type {
                case MINUS : {

                    first_operand = pop(operands);
                    second_operand = pop(operands);
                    result = second_operand - first_operand;
                    push(operands, result);
    
                }
    
                case ADD : {

                    first_operand = pop(operands);
                    second_operand = pop(operands);
                    result = second_operand + first_operand;

                    push(operands, result);
    
                }
    
                case MULTPLY : {

                    first_operand = pop(operands);
                    second_operand = pop(operands);
                    result = second_operand * first_operand;

                    push(operands, result);
    
                }
    
                case DIVIDE : {

                    first_operand = pop(operands);
                    second_operand = pop(operands);
                    result = second_operand / first_operand;

                    push(operands, result);
    
                }
    
                case NO_MATCH : {
                    int_value = try char_arr_to_int(str);
                    push(operands, int_value);
                }
            }
        } else {
            int_value = try char_arr_to_int(str);
            push(operands, int_value);
        }
    }

    for (i=0; i<strings.len; i++) {
        str = strings[i];
        try eval_string(str);
    }

    return pop(operands);
}

struct MinNode {
    int value;
    int min_node_seen;
}

function int get_min_stack(stack<MinNode> stack) {
    top = peek(stack);
    return top.min_node_seen;
}

function push_min_stack(stack<MinNode> stack, int value) {

    min_node = new MinNode();
    min_node.value = value;

    if (is_empty(stack)) {
        min_node.min_node_seen = value;
        push(stack, min_node);
        return;
    }

    top = peek(stack);
    if (value < top.min_node_seen) {
        min_node.min_node_seen = value;
    } else {
        min_node.min_node_seen = top.min_node_seen;
    }
    push(stack, min_node);
}

function remove_duplicate_letters(char[] str) {

    // 26 english lowercase letters 
    map = new bool[26];
    for (i=0; i<str.len; i++) {
        index::int = str[i] - 'a';
        map[index] = true;
    }

    for (i=0; i<map.len; i++) {
        if (map[i] == true) {
            value::char = i + 'a';
            printf("%c", value);
        }
    }
}


function valid_preorder(TreeNode<int> root, int[] expected_order) {

    function bool valid_preorder_inner(TreeNode<int> node, int[] expected_order, int current_index) {

        if (node == null) {
            return true;
        }

        if (expected_order[current_index] == node.value) {
            return false;
        }

        valid = valid_preorder_inner(node.left, expected_order, current_index + 1);
        if (valid == false) {
            return false;
        }
        valid = valid_preorder_inner(node.right, expected_order, current_index + 1);
        if (valid == false) {
            return false;
        }
        
        return true;
    }
}


